# Решения ДЗ 1 -- Канальное кодирование

## ДЗ 1. Код (5, 2)

### Таблица кода

| ИС | КС    | Вес |
|----|-------|-----|
| 00 | 00000 | 0   |
| 01 | 10110 | 3   |
| 10 | 01011 | 3   |
| 11 | 11101 | 4   |

Параметры: n = 5, k = 2, скорость R = k/n = 2/5.

### 1.1. Вероятность ошибки при p = 10^(-3)

#### Проверка линейности

Сумма любых двух кодовых слов должна быть кодовым словом:

    10110 XOR 01011 = 11101 -- есть в коде
    10110 XOR 11101 = 01011 -- есть в коде
    01011 XOR 11101 = 10110 -- есть в коде

Код линейный. Значит d_min = минимальный вес ненулевого слова = min(3, 3, 4) = 3.

#### Корректирующая способность

    t = floor((d_min - 1) / 2) = floor((3 - 1) / 2) = 1

Код гарантированно исправляет 1 ошибку.

#### Вычисление вероятности ошибки

Без потери общности считаем, что передано нулевое слово c = 00000 (код линейный, вероятность ошибки одинакова для всех кодовых слов).

При декодировании по ближайшему соседу ошибка происходит, когда принятое слово оказывается ближе к другому КС, чем к переданному. Код исправляет все одиночные ошибки, значит ошибка декодирования -- при 2+ ошибках в блоке из 5:

    P_ош = SUM(i=2..5) C(5,i) * p^i * (1-p)^(5-i)

Раскладываем по слагаемым:

    i=2: C(5,2) * p^2 * (1-p)^3 = 10 * 10^(-6) * 0.997 ~ 9.97 * 10^(-6)
    i=3: C(5,3) * p^3 * (1-p)^2 = 10 * 10^(-9) * 0.998 ~ 10^(-8)
    i=4: C(5,4) * p^4 * (1-p)   = 5  * 10^(-12)          ~ 5 * 10^(-12)
    i=5: C(5,5) * p^5           = 10^(-15)

Доминирует первый член:

    P_ош ~ 10 * p^2 = 10 * 10^(-6) = 10^(-5)

Эквивалентная формула:

    P_ош = 1 - (1-p)^5 - 5*p*(1-p)^4
         = 1 - 0.995 - 5 * 0.001 * 0.996
         = 1 - 0.995010 - 0.004980
         ~ 0.000010 = 10^(-5)

#### Сравнение

| Способ передачи        | R   | P_ош            |
|------------------------|-----|-----------------|
| Без кодирования        | 1   | 10^(-3)         |
| Код повторения (3, 1)  | 1/3 | ~ 3 * 10^(-6)   |
| Код (5, 2)             | 2/5 | ~ 10^(-5)       |

Код (5, 2) улучшает надежность на два порядка при скорости выше, чем у тройного повторения.

---

### 1.2. Порождающая матрица G

#### Построение

Строки G -- кодовые слова, соответствующие единичным информационным словам:

    ИС = 10 -> КС = 01011 = g1
    ИС = 01 -> КС = 10110 = g2

|   | 1 | 2 | 3 | 4 | 5 |
|---|---|---|---|---|---|
| g1| 0 | 1 | 0 | 1 | 1 |
| g2| 1 | 0 | 1 | 1 | 0 |

#### Проверка: c = m * G

    m = (0,0): 0*g1 + 0*g2 = 00000  -- ok
    m = (1,0): 1*g1 + 0*g2 = 01011  -- ok
    m = (0,1): 0*g1 + 1*g2 = 10110  -- ok
    m = (1,1): g1 XOR g2 = 01011 XOR 10110 = 11101  -- ok

Все совпадают с таблицей.

---

### 1.3. Проверочная матрица H

#### Построение

Ищем H размера (n-k) x n = 3 x 5. Каждая строка h = (h1, h2, h3, h4, h5) удовлетворяет:

    g1 * h^T = 0:  h2 + h4 + h5 = 0  (mod 2)
    g2 * h^T = 0:  h1 + h3 + h4 = 0  (mod 2)

Два уравнения, пять неизвестных -- три свободных переменных (h3, h4, h5). Выражаем:

    h2 = h4 + h5
    h1 = h3 + h4

Подставляем базисные значения:

| h3 | h4 | h5 | h1 = h3+h4 | h2 = h4+h5 | строка H        |
|----|----|----|------------|------------|-----------------|
| 1  | 0  | 0  | 1          | 0          | (1, 0, 1, 0, 0) |
| 0  | 1  | 0  | 1          | 1          | (1, 1, 0, 1, 0) |
| 0  | 0  | 1  | 0          | 1          | (0, 1, 0, 0, 1) |

|   | 1 | 2 | 3 | 4 | 5 |
|---|---|---|---|---|---|
| h1| 1 | 0 | 1 | 0 | 0 |
| h2| 1 | 1 | 0 | 1 | 0 |
| h3| 0 | 1 | 0 | 0 | 1 |

#### Проверка G * H^T = 0

    g1 * h1^T = 0+0+0+0+0 = 0  ok
    g1 * h2^T = 0+1+0+1+0 = 0  ok
    g1 * h3^T = 0+1+0+0+1 = 0  ok
    g2 * h1^T = 1+0+1+0+0 = 0  ok
    g2 * h2^T = 1+0+0+1+0 = 0  ok
    g2 * h3^T = 0+0+0+0+0 = 0  ok

#### Проверка c * H^T = 0 для всех КС

Вычисляем синдром s = c * H^T для каждого КС:

    c = 00000:  s = (0, 0, 0)  ok
    c = 10110:
        s1 = 1*1+0*0+1*1+1*0+0*0 = 1+1 = 0
        s2 = 1*1+0*1+1*0+1*1+0*0 = 1+1 = 0
        s3 = 1*0+0*1+1*0+1*0+0*1 = 0
        s = (0, 0, 0)  ok
    c = 01011:
        s1 = 0*1+1*0+0*1+1*0+1*0 = 0
        s2 = 0*1+1*1+0*0+1*1+1*0 = 1+1 = 0
        s3 = 0*0+1*1+0*0+1*0+1*1 = 1+1 = 0
        s = (0, 0, 0)  ok
    c = 11101:
        s1 = 1*1+1*0+1*1+0*0+1*0 = 1+1 = 0
        s2 = 1*1+1*1+1*0+0*1+1*0 = 1+1 = 0
        s3 = 1*0+1*1+1*0+0*0+1*1 = 1+1 = 0
        s = (0, 0, 0)  ok

Все синдромы нулевые.

---

## ДЗ 2. Расстояние Хэмминга -- метрика

### Определение

d(x, y) = число позиций i, где x_i != y_i.

Нужно показать 4 аксиомы метрики.

### 1) Неотрицательность: d(x, y) >= 0

d(x, y) -- мощность множества {i : x_i != y_i}. Мощность множества всегда неотрицательна.   QED

### 2) Тождество неразличимых: d(x, y) = 0 <=> x = y

(=>) Если d(x, y) = 0, то нет ни одной позиции, где x и y различаются. Значит x_i = y_i для всех i, т.е. x = y.

(<=) Если x = y, то x_i = y_i для всех i, различающихся позиций нет. Значит d(x, y) = 0.   QED

### 3) Симметричность: d(x, y) = d(y, x)

Отношение "x_i != y_i" симметрично: x_i != y_i <=> y_i != x_i. Множество позиций, в которых x и y различаются, совпадает с множеством позиций, в которых y и x различаются.   QED

### 4) Неравенство треугольника: d(x, z) <= d(x, y) + d(y, z)

Обозначим:

    A = {i : x_i != z_i},  |A| = d(x, z)
    B = {i : x_i != y_i},  |B| = d(x, y)
    C = {i : y_i != z_i},  |C| = d(y, z)

Покажем, что A -- подмножество (B объединение C).

Пусть i принадлежит A, т.е. x_i != z_i. Два случая:

    Случай 1: x_i != y_i  =>  i принадлежит B
    Случай 2: x_i = y_i   =>  из x_i != z_i следует y_i != z_i  =>  i принадлежит C

В обоих случаях i принадлежит (B объединение C). Значит A -- подмножество (B объединение C).

Отсюда:

    d(x, z) = |A| <= |B объединение C| <= |B| + |C| = d(x, y) + d(y, z)

QED

---

## ДЗ 3. Теорема о корректирующей способности

### Формулировка

Код с минимальным расстоянием d_min при декодировании по ближайшему соседу исправляет все комбинации ошибок кратности t <= floor((d_min - 1) / 2).

### Доказательство (от противного)

Пусть t <= floor((d_min - 1) / 2). Тогда:

    2t <= d_min - 1, т.е. 2t + 1 <= d_min   ... (*)

Передано кодовое слово c1. В канале произошло s <= t ошибок. Принятое слово:

    y = c1 + e,  где w(e) = s <= t

Значит d(y, c1) = s <= t.

Допустим (от противного), что существует другое кодовое слово c2 != c1 такое, что:

    d(y, c2) <= d(y, c1) <= t

По неравенству треугольника:

    d(c1, c2) <= d(c1, y) + d(y, c2) <= t + t = 2t

Но c1 != c2, значит d(c1, c2) >= d_min. Получаем:

    d_min <= d(c1, c2) <= 2t

Но из (*): d_min >= 2t + 1 > 2t. Противоречие.

Значит не существует кодового слова c2 != c1 на расстоянии <= t от y. Декодер по ближайшему соседу однозначно и правильно выберет c1.   QED

### Геометрическая интерпретация

Вокруг каждого кодового слова -- "сфера" радиуса t (все слова на расстоянии не более t). Условие d_min >= 2t + 1 гарантирует, что сферы не пересекаются: любое принятое слово попадает максимум в одну сферу.

---

## ДЗ 4. Код (6, 3)

### Таблица кода

| ИС  | КС     |
|-----|--------|
| 000 | 000000 |
| 100 | 110100 |
| 010 | 011010 |
| 110 | 101110 |
| 001 | 101001 |
| 101 | 011101 |
| 011 | 110011 |
| 111 | 000111 |

Параметры: n = 6, k = 3, R = 1/2.

### 4.1. Порождающая матрица G

#### Построение

Строки G -- кодовые слова при единичных ИС:

    ИС = 100 -> КС = 110100 = g1
    ИС = 010 -> КС = 011010 = g2
    ИС = 001 -> КС = 101001 = g3

|   | 1 | 2 | 3 | 4 | 5 | 6 |
|---|---|---|---|---|---|---|
| g1| 1 | 1 | 0 | 1 | 0 | 0 |
| g2| 0 | 1 | 1 | 0 | 1 | 0 |
| g3| 1 | 0 | 1 | 0 | 0 | 1 |

G имеет систематическую форму G = (P | I_3), где позиции 4, 5, 6 -- информационные:

P:

|   | 1 | 2 | 3 |
|---|---|---|---|
|   | 1 | 1 | 0 |
|   | 0 | 1 | 1 |
|   | 1 | 0 | 1 |

#### Проверка: c = m * G

    m = (0,0,0): 000000  ok
    m = (1,0,0): g1 = 110100  ok
    m = (0,1,0): g2 = 011010  ok
    m = (1,1,0): g1 XOR g2 = 110100 XOR 011010 = 101110  ok
    m = (0,0,1): g3 = 101001  ok
    m = (1,0,1): g1 XOR g3 = 110100 XOR 101001 = 011101  ok
    m = (0,1,1): g2 XOR g3 = 011010 XOR 101001 = 110011  ok
    m = (1,1,1): g1 XOR g2 XOR g3 = 101110 XOR 101001 = 000111  ok

Все совпадают с таблицей.

### 4.2. Проверочная матрица H

#### Построение

Для G = (P | I_k) проверочная матрица H = (I_(n-k) | P^T):

P^T:

|   | 1 | 2 | 3 |
|---|---|---|---|
|   | 1 | 0 | 1 |
|   | 1 | 1 | 0 |
|   | 0 | 1 | 1 |

H (3 x 6):

|   | 1 | 2 | 3 | 4 | 5 | 6 |
|---|---|---|---|---|---|---|
| h1| 1 | 0 | 0 | 1 | 0 | 1 |
| h2| 0 | 1 | 0 | 1 | 1 | 0 |
| h3| 0 | 0 | 1 | 0 | 1 | 1 |

#### Проверка G * H^T = 0

    g1 * h1^T = 1*1 + 1*0 + 0*0 + 1*1 + 0*0 + 0*1 = 1+1 = 0  ok
    g1 * h2^T = 1*0 + 1*1 + 0*0 + 1*1 + 0*1 + 0*0 = 1+1 = 0  ok
    g1 * h3^T = 1*0 + 1*0 + 0*1 + 1*0 + 0*1 + 0*1 = 0  ok
    g2 * h1^T = 0*1 + 1*0 + 1*0 + 0*1 + 1*0 + 0*1 = 0  ok
    g2 * h2^T = 0*0 + 1*1 + 1*0 + 0*1 + 1*1 + 0*0 = 1+1 = 0  ok
    g2 * h3^T = 0*0 + 1*0 + 1*1 + 0*0 + 1*1 + 0*1 = 1+1 = 0  ok
    g3 * h1^T = 1*1 + 0*0 + 1*0 + 0*1 + 0*0 + 1*1 = 1+1 = 0  ok
    g3 * h2^T = 1*0 + 0*1 + 1*0 + 0*1 + 0*1 + 1*0 = 0  ok
    g3 * h3^T = 1*0 + 0*0 + 1*1 + 0*0 + 0*1 + 1*1 = 1+1 = 0  ok

#### Проверка c * H^T = 0 для всех КС

    000000: s = (0, 0, 0)  ok
    110100: s1 = 1+1+1 = 1+1+1... пересчет поэлементно:
        s1 = 1*1+1*0+0*0+1*1+0*0+0*1 = 1+1 = 0
        s2 = 1*0+1*1+0*0+1*1+0*1+0*0 = 1+1 = 0
        s3 = 1*0+1*0+0*1+1*0+0*1+0*1 = 0
        s = (0, 0, 0)  ok
    011010:
        s1 = 0+1*0+1*0+0+1*0+0 = 0
        s2 = 0+1*1+1*0+0+1*1+0 = 1+1 = 0
        s3 = 0+1*0+1*1+0+1*1+0 = 1+1 = 0
        s = (0, 0, 0)  ok
    101110:
        s1 = 1+0+0+1+1*0+0 = 1+1 = 0
        s2 = 0+0+0+1+1+0 = 1+1 = 0
        s3 = 0+0+1+0+1+0 = 1+1 = 0
        s = (0, 0, 0)  ok
    101001:
        s1 = 1+0+0+0+0+1 = 1+1 = 0
        s2 = 0+0+0+0+0+0 = 0
        s3 = 0+0+1+0+0+1 = 1+1 = 0
        s = (0, 0, 0)  ok
    011101:
        s1 = 0+1*0+1*0+1+0+1 = 1+1 = 0
        s2 = 0+1+0+1+0+0 = 1+1 = 0
        s3 = 0+0+1+0+0+1 = 1+1 = 0
        s = (0, 0, 0)  ok
    110011:
        s1 = 1+0+0+0+0+1 = 1+1 = 0
        s2 = 0+1+0+0+1+0 = 1+1 = 0
        s3 = 0+0+0+0+1+1 = 1+1 = 0
        s = (0, 0, 0)  ok
    000111:
        s1 = 0+0+0+1+0+1 = 1+1 = 0
        s2 = 0+0+0+1+1+0 = 1+1 = 0
        s3 = 0+0+0+0+1+1 = 1+1 = 0
        s = (0, 0, 0)  ok

Все синдромы нулевые.
